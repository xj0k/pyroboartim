

Layouts
=======

While at this point in the documentation you've not been shown very much about each Element available, you should read this section carefully as you can use the techniques you learn in here to build better, shorter, and easier to understand PySimpleGUI code.

If it feels like this layout section is too much too soon, then come back to this section after you're learned about each Element. **Whatever order you find the least confusing is the best.**

While you've not learned about Elements yet, it makes sense for this section to be up front so that you'll have learned how to use the elements prior to learning how each element works. At this point in your PySimpleGUI education, it is better for you to grasp time efficient ways of working with Elements than what each Element does. By learning now how to assemble Elements now, you'll have a good model to put the elements you learn into.

There are *several* aspects of PySimpleGUI that make it more "Pythonic" than other Python GUI SDKs. One of the areas that is unique to PySimpleGUI is how a window's "layout" is defined, specified or built. A window's "layout" is simply a list of lists of elements. As you've already learned, these lists combine to form a complete window. This method of defining a window is super-powerful because lists are core to the Python language as a whole and thus are very easy to create and manupulate.

Think about that for a moment and compare/contrast with Qt, tkinter, etc. With PySimpleGUI the location of your element in a matrix determines where that Element is shown in the window. It's so ***simple*** and that makes it incredibly powerful. Want to switch a row in your GUI that has text with the one below it that has an input element? No problem, swap the lines of code and you're done.

Layouts were designed to be visual. The idea is for you to be able to envision how a window will look by simplyh looking at the layout in the code. The CODE itself matches what is drawn on the screen. PySimpleGUI is a cross between straight Python code and a visual GUI designer.

In the process of creating your window, you can manipulate these lists of elements without having an impact on the elements or on your window. Until you perform a "layout" of the list, they are nothing more than lists containing objects (they just happen to be your window's elements).

Many times your window definition / layout will be a static, straightforward to create.

However, window layouts are not limited to being one of these staticly defined list of Elements.

Generated Layouts (For sure want to read if you have \> 5 repeating elements/rows)
==================================================================================

There are 5 specific techniques of generating layouts discussed in this section. They can be used alone or in combination with each other.

1.  Layout + Layout concatenation `[[A]] + [[B]] = [[A], [B]]`
2.  Element Addition on Same Row `[[A] + [B]] = [[A, B]]`
3.  List Comprehension to generate a row `[A for x in range(10)] = [A,A,A,A,A...]`
4.  List Comprehension to generate multiple rows `[[A] for x in range(10)] = [[A],[A],...]`
5.  User Defined Elements / Comound Elements

Example - List Comprehension To Concatenate Multiple Rows - "To Do" List Example
--------------------------------------------------------------------------------

Let's create a little layout that will be used to make a to-do list using PySimpleGUI.

### Brute Force

    import PySimpleGUI as sg
    
    layout = [
                [sg.Text('1. '), sg.In(key=1)],
                [sg.Text('2. '), sg.In(key=2)],
                [sg.Text('3. '), sg.In(key=3)],
                [sg.Text('4. '), sg.In(key=4)],
                [sg.Text('5. '), sg.In(key=5)],
                [sg.Button('Save'), sg.Button('Exit')]
             ]
    
    window = sg.Window('To Do List Example', layout)
    event, values = window.read()

The output from this script was this window:

<span class="image">SNAG-0451</span>

Take a moment and look at the code and the window that's generated. Are you able to look at the layout and envision the Window on the screen?

### Build By Concatenating Rows

The brute force method works great on a list that's 5 items long, but what if your todo list had 40 items on it. THEN what? Well, that's when we turn to a "generated" layout, a layout that is generated by your code. Replace the layout= stuff from the previous example with this definition of the layout.

    import PySimpleGUI as sg
    
    layout = []
    for i in range(1,6):
        layout += [sg.Text(f'{i}. '), sg.In(key=i)],
    layout += [[sg.Button('Save'), sg.Button('Exit')]]
    
    window = sg.Window('To Do List Example', layout)
    event, values = window.read()

It produces the exact same window of course. That's progress.... went from writing out every row of the GUI to generating every row. If we want 48 items as suggested, change the range(1,6) to range(1,48). Each time through the list another row is added onto the layout.

### Create Several Rows Using List Comprehension

BUT, we're not done yet!

This is **Python**, we're using lists to build something up, so we should be looking at ***\*list comprehensions***\*. Let's change the `for` loop into a list comprehension. Recall that our `for` loop was used to concatenate 6 rows into a layout.

    layout =  [[sg.Text(f'{i}. '), sg.In(key=i)] for i in range(1,6)] 

Here we've moved the `for` loop to inside of the list definition (a list comprehension)

### Concatenating Multiple Rows

We have our rows built using the list comprehension, now we just need the buttons. They can be easily "tacked onto the end" by simple addition.

    layout =  [[sg.Text(f'{i}. '), sg.In(key=i)] for i in range(1,6)] 
    layout += [[sg.Button('Save'), sg.Button('Exit')]]

Anytime you have 2 layouts, you can concatenate them by simple addition. Make sure your layout is a "list of lists" layout. In the above example, we know the first line is a generated layout of the input rows. The last line adds onto the layout another layout... note the format being \[ \[ \] \].

This button definition is an entire layout, making it possible to add to our list comprehension

`[[sg.Button('Save'), sg.Button('Exit')]]`

It's quite readable code. The 2 layouts line up visually quite well.

But let's not stop there with compressing the code. How about removing that += and instead change the layout into a single line with just a `+` between the two sets of row.

Doing this concatenation on one line, we end up with this single statement that creates the **entire layout** for the GUI:

    layout =  [[sg.Text(f'{i}. '), sg.In(key=i)] for i in range(1,6)] + [[sg.Button('Save'), sg.Button('Exit')]]

### Final "To Do List" Program

And here we have our final program... all **4** lines.

    import PySimpleGUI as sg
    
    layout  = [[sg.Text(f'{i}. '), sg.In(key=i)] for i in range(1,6)] + [[sg.Button('Save'), sg.Button('Exit')]]
    
    window = sg.Window('To Do List Example', layout)
    
    event, values = window.read()

If you really wanted to crunch things down, you can make it a 2 line program (an import and 1 line of code) by moving the layout into the call to `Window`

    import PySimpleGUI as sg
    
    event, values = sg.Window('To Do List Example', layout=[[sg.Text(f'{i}. '), sg.In(key=i)] for i in range(1,6)] + [[sg.Button('Save'), sg.Button('Exit')]]).Read()

Example - List Comprehension to Build Rows - Table Simulation - Grid of Inputs
------------------------------------------------------------------------------

In this example we're building a "table" that is 4 wide by 10 high using `Input` elements

The end results we're seeking is something like this:

    HEADER 1    HEADER 2    HEADER 3    HEADER 4
    INPUT       INPUT       INPUT       INPUT
    INPUT       INPUT       INPUT       INPUT
    INPUT       INPUT       INPUT       INPUT
    INPUT       INPUT       INPUT       INPUT
    INPUT       INPUT       INPUT       INPUT
    INPUT       INPUT       INPUT       INPUT
    INPUT       INPUT       INPUT       INPUT
    INPUT       INPUT       INPUT       INPUT
    INPUT       INPUT       INPUT       INPUT
    INPUT       INPUT       INPUT       INPUT

Once the code is completed, here is how the result will appear:

<span class="image">image</span>

We're going to be building each row using a list comprehension and we'll build the table by concatenating rows using another list comprehension. That's a list comprehension that goes across and another list comprehension that goes down the layout, adding one row after another.

### Building the Header

First let's build the header. There are 2 concepts to notice here:

    import PySimpleGUI as sg
    
    headings = ['HEADER 1', 'HEADER 2', 'HEADER 3','HEADER 4']  # the text of the headings
    header =  [[sg.Text('  ')] + [sg.Text(h, size=(14,1)) for h in headings]]  # build header layout

There are 2 things in this code to note 1. The list comprehension that makes the heading elements 2. The spaces added onto the front

Let's start with the headers themselves.

This is the code that makes a row of Text Elements containing the text for the headers. The result is a list of Text Elements, a row.

    [sg.Text(h, size=(14,1)) for h in headings]

Then we add on a few spaces to shift the headers over so they are centered over their columns. We do this by simply adding a `Text` Element onto the front of that list of headings.

    header =  [[sg.Text('  ')] + [sg.Text(h, size=(14,1)) for h in headings]]

This `header` variable is a layout with 1 row that has a bunch of `Text` elements with the headings.

### Building the Input Elements

The `Input` elements are arranged in a grid. To do this we will be using a double list comprehension. One will build the row the other will add the rows together to make the grid. Here's the line of code that does that:

    input_rows = [[sg.Input(size=(15,1), pad=(0,0)) for col in range(4)] for row in range(10)]

This portion of the statement makes a single row of 4 `Input` Elements

    [sg.Input(size=(15,1), pad=(0,0)) for col in range(4)]

Next we take that list of `Input` Elements and make as many of them as there are rows, 10 in this case. We're again using Python's awesome list comprehensions to add these rows together.

    input_rows = [[sg.Input(size=(15,1), pad=(0,0)) for col in range(4)] for row in range(10)]

The first part should look familiar since it was just discussed as being what builds a single row. To make the matrix, we simply take that single row and create 10 of them, each being a list.

### Putting it all together

Here is our final program that uses simple addition to add the headers onto the top of the input matrix.

    import PySimpleGUI as sg
    
    headings = ['HEADER 1', 'HEADER 2', 'HEADER 3','HEADER 4']
    header =  [[sg.Text('  ')] + [sg.Text(h, size=(14,1)) for h in headings]]
    
    input_rows = [[sg.Input(size=(15,1), pad=(0,0)) for col in range(4)] for row in range(10)]
    
    layout = header + input_rows
    
    window = sg.Window('Table Simulation', layout, font='Courier 12')
    event, values = window.read()

User Defined Elements / Compound Elements
-----------------------------------------

"User Defined Elements" and "Compound Elements" are one or more PySimpleGUI Elements that are wrapped in a function definition. In a layout, they have the appearance of being a custom elements of some type.

User Defined Elements are particularly useful when you set a lot of parameters on an element that you use over and over in your layout.

### Example - A Grid of Buttons for Calculator App

Let's say you're making a calculator application with buttons that have these settings:

-   font = Helvetica 20
-   size = 5,1
-   button color = white on blue

The code for **one** of these buttons is:

    sg.Button('1', button_color=('white', 'blue'), size=(5, 1), font=("Helvetica", 20))

If you have 6 buttons across and 5 down, your layout will have 30 of these lines of text.

One row of these buttons could be written:

        [sg.Button('1', button_color=('white', 'blue'), size=(5, 1), font=("Helvetica", 20)),
         sg.Button('2', button_color=('white', 'blue'), size=(5, 1), font=("Helvetica", 20)),
         sg.Button('3', button_color=('white', 'blue'), size=(5, 1), font=("Helvetica", 20)),
         sg.Button('log', button_color=('white', 'blue'), size=(5, 1), font=("Helvetica", 20)),
         sg.Button('ln', button_color=('white', 'blue'), size=(5, 1), font=("Helvetica", 20)),
         sg.Button('-', button_color=('white', 'blue'), size=(5, 1), font=("Helvetica", 20))],

By using User Defined Elements, you can significantly shorten your layouts. Let's call our element `CBtn`. It would be written like this:

    def CBtn(button_text):
        return sg.Button(button_text, button_color=('white', 'blue'), size=(5, 1), font=("Helvetica", 20))

Using your new `CBtn` Element, you could rewrite the row of buttons above as:

    [CBtn('1'), CBtn('2'), CBtn('3'), CBtn('log'), CBtn('ln'), CBtn('-')],

See the tremendous amount of code you do not havew to write! USE this construct any time you find yourself copying an element many times.

But let's not stop there.

Since we've been discussing list comprehensions, let's use them to create this row. The way to do that is to make a list of the symbols that go across the row make a loop that steps through that list. The result is a list that looks like this:

    [CBtn(t) for t in ('1','2','3', 'log', 'ln', '-')],

That code produces the same list as this one we created by hand:

    [CBtn('1'), CBtn('2'), CBtn('3'), CBtn('log'), CBtn('ln'), CBtn('-')],

### Compound Elements

Just like a `Button` can be returned from a User Defined Element, so can multiple Elements.

Going back to the To-Do List example we did earlier, we could have defined a User Defined Element that represented a To-Do Item and this time we're adding a checkbox. A single line from this list will be:

-   The item \# (a `Text` Element)
-   A `Checkbox` Element to indicate completed
-   An `Input` Element to type in what to do

The definition of our User Element is this `ToDoItem` function. It is a single User Element that is a combination of 3 PySimpleGUI Elements.

    def ToDoItem(num):
        return [sg.Text(f'{num}. '), sg.CBox(''), sg.In()]

This makes creating a list of 5 to-do items downright trivial when combined with the list comprehension techniques we learned earlier. Here is the code required to create 5 entries in our to-do list.

    layout = [ToDoItem(x) for x in range(1,6)]

We can then literally add on the buttons

    layout = [ToDoItem(x) for x in range(1,6)] + [[sg.Button('Save'), sg.Button('Exit')]]

And here is our final program

    import PySimpleGUI as sg
    
    def ToDoItem(num):
        return [sg.Text(f'{num}. '), sg.CBox(''), sg.In()]
    
    layout = [ToDoItem(x) for x in range(1,6)] + [[sg.Button('Save'), sg.Button('Exit')]]
    
    window = sg.Window('To Do List Example', layout)
    event, values = window.read()

And the window it creates looks like this:

<span class="image">image</span>